---
title: "Data Science das Cervejas (2/2)"
author: "Giuliano Sposito"
date: '2018-02-13'
coverImage: /images/beertm_cover.jpg
metaAlignment: center
slug: data-science-das-cervejas-2-2
tags:
- beer
- pt-BR
- data analysis
- rstats
- text mining
thumbnailImage: images/beertm_tn.png
thumbnailImagePosition: left
categories: data science
---

Esta é a segunda parte do post sobre análise de textos usando avaliações de cerveja extraído da web. Nele analisaremos as semelhanças entre os tipos de cervejas, ou seja, que cervejas possuem mesmas características de sabor, cor e malte, independentemente do seu tipo. Isso é um aspecto importante no campo de _Data Science_, pois permite encontrar "sugestões" de consumo, para usuários que apreciam um determinado produto.

<!--more-->


```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# setup
library(knitr)

# default behavior for chunks
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(cache = TRUE)
```

## Que cerveja é similar a outra?

O primeiro passo é encontrar as semelhança entre os tipos de cerveja, para tal vamos recuperar os dados obtidos do post anterior, a base de descrição de cervejas e a contagem de palavras por tipo.

```{r loading}

# libs
library(tidyverse) # pipe, maps and tibble
library(lubridate) # manipulacao de datas
library(corrplot)  # correlation plot
library(ape)       # disk dendogram
library(RColorBrewer) # color palette
library(tidytext) # pacote para tratamento de textos do tidyverse 

# recuperando contagem de palavras gravada no post anterior
beers <- readRDS("./data/beer_tm/beers.rds")
beer_wordc <- readRDS("./data/beer_tm/beer_wordc.rds")
glimpse(beer_wordc)
```

### Correlação

A técnica mais óbvia para determinar semelhança entre tipos é correlacionar a frequência das palavras encontradas nas descrições entre os diversos tipos. Ou seja, tipos que possuem frequentemente a mesma palavra são tipos que são semelhantes entre si.

Por exemplo, se a Weiss é descrita com "sabor de trigo" e a WitBier também contém "trigo" na descrição, então elas são semelhantes, mais semelhantes conforme a frequência de "trigo" aparece nas descrições das diversas cervejas de ambas categorias.

Então, vamos tabular a frequência de cada uma das palavras em cada um dos tipos de cerveja.

```{r wordFreq}

# vamos limitar a analise aos tipos que possuem mais de 3 avaliações
# para facilitar a visualização dos dados 
beers %>% 
  group_by(tipo) %>% 
  tally() %>% 
  filter(n>3) -> selected.types

# a partir da contagem de palavras por tipo
beer_corr <- beer_wordc %>%
  # selecionar os tipos que interessam
  filter(tipo %in% selected.types$tipo) %>%
  select(-super.tipo) %>%
  # por tipo calcular a porporcao em que a palavra aparece
  group_by(tipo) %>%
  mutate(proporcao = n / sum(n))  %>%
  # manter as palabras (por tipo) que aparecem com mais frequencia
  subset(n >= 5) %>%
  select(-n) %>%
  # pivotar para ter "palavra" x "tipo"
  spread(tipo, proporcao)

# zerar as células em que o tipo não possuem a palavra (NA -> 0)
beer_corr[is.na(beer_corr)] <- 0 

# mostrando um subset da tabulacao
beer_corr[1:10, 1:10] %>%
  kable()
```


Contamos então a frequência com que cada uma das palavras (linhas) aparece, frente as outras palavras, para cada tipo de cerveja (colunas). Para descobrir qual tipo é mais semelhante com o outro, basta calcular a correlação entre os tipos, usaremos a função `cor()` a correlação e a função `corrplot` para visualizá-la.

```{r plotCorr, fig.height=8, fig.width=8}

# definindo uma palheta de core para escala de correlação [-1,1]
mycol <- colorRampPalette(c("red", "lightsalmon", "white", "paleturquoise", "blue"))

# calculando a correlação (tirando a primeira coluna que é a palavra)
cor(beer_corr[,-1], use = "pairwise.complete.obs") %>%  
  # plotando a correlação, organizando como um hclust
  corrplot(method="color", order="hclust", diag=FALSE, 
           tl.col = "black", tl.srt = 45, tl.cex=0.6,
           col=mycol(100), 
           # triangulo inferior (já que é uma matriz simétrica)
           type="lower",
           title="Correlaçao entre Tipos de Cerveja",
           mar=c(0,0,1,0))


```

Nesse plot, podemos observar o grau de similaridade entre os tipos de cerveja e verificar que há estruturas entre alguns tipos. já pedimos para o plot aproximar os itens semelhantes entre si (parâmetro `hclust`), então a ordenação reflete essa informação.

### Clusters

Outra maneira de encontrar os tipos mais semelhantes é _clusterizar_, para tal, tratamos cada palavra como uma dimensão no espaço de descrições, e então usamos a frequência com que ela ocorre como um ponto neste espaço, a partir daí calculamos a distancia entre cada um dos pontos e então _clusterizamos_, agrupando os tipos mais próximos entre si.

```{r hclusterPlot, fig.height=9, fig.width=9}

# removendo a coluna
beer_corr[,-1] %>%
  # transpondo: observação (tipo) na linha e features nas colunas (palavras)
  t() %>%
  # calculando a distancia (euclidiana) entre as observações
  dist(method="euclidean") -> beer.dist

beer.dist %>%
  # clusterizando (hierarquicamente)
  hclust(method="ward.D") -> beer.clusters

# agrupando em 10 tipos distintos
clusters = cutree(beer.clusters, 10)

# palheta de cores para visualizacao (10 grupos)
colors = RColorBrewer::brewer.pal(10,"Paired")

# plotando como uma "roda"
plot(as.phylo(beer.clusters), type = "fan", tip.color = colors[clusters],
     label.offset = 0, cex = 0.9)
```

A clusterização aproxima tipos de cervejas diferentes mas que possuem as mesmas características de sabor, cor e malte. Note que o número de grupos é relativamente "arbitrário", nos escolhemos agrupar por distância em 10 grupos quando aplicamos o `cutree`. 


Vamos ver as palavras que definem dois tipos diferentes que foram colocados juntos: a _English Poter_ e a _American Brown Ale_.

```{r twoSimilarBeers}

# partindo da contagem de palavras
beer_wordc %>%
  # somente os tipos de interesse
  filter( tipo %in% c("Porter (English Porter)","Brown Ale (American Brown Ale)"),
          n>1) %>%
  # conta por tipo
  group_by(word, super.tipo) %>%
  summarise(n=sum(n)) %>%
  group_by(super.tipo) %>%
  # seleciona as 15 mais frequentes palavras
  top_n(15, n) %>%
  # garante que são  somente as 15 mesmos
  filter(row_number() <= 15) %>%
  # ordena 
  arrange(super.tipo, desc(n)) %>%
  ungroup() %>%
  # atribui um rank para cada palavra dentro do tipo (facilitar o plot) 
  mutate(Rank = rep(15:1, 2)) %>%
  # styling omitted for brevity
  ggplot(aes(x=as.factor(Rank), y=n)) +  
    geom_bar(stat="identity", fill="cadetblue", alpha=0.5) + 
    coord_flip() + facet_wrap(~super.tipo,ncol=4) + 
    geom_text(aes(label=word, x=Rank), y=0,hjust=0, size=4) +
    labs(title="15 palavras com mais comuns para cada tipo", 
         x="", y="n") +
    theme_bw() + 
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())




```
 
 Podemos notar que há uma série de palavras comuns descrevendo ambos os tipos, como `maltada`, `café`, `cevada`, `espuma` e `duradouro`. Características comuns desse tipo de cerveja.
 
 Mas e se quiséssemos evidenciar o que difere uma tipo do outro? Usaríamos a mesma técnica usada no post anterior, calcularíamos quais as palavras mais importantes, distintas entre as descrições dos dois tipos, usando TF_IDF.


```{r twoBeersDifferences}
# partindo da contagem de palavras
beer_wordc %>%
  # somente dos tipos interessados
  filter( tipo %in% c("Porter (English Porter)","Brown Ale (American Brown Ale)"),
          n>1) %>%
  # agrupa a contagem por tipo
  group_by(word, super.tipo) %>%
  summarise(n=sum(n)) %>%
  # calcula o total por palavra
  group_by(word) %>%
  mutate(word_total = sum(n)) %>%
  # calcula o TF_IDF
  bind_tf_idf(word, super.tipo, n)  %>%
  # remove quem obteve zero de score e ordena descrescente
  subset(tf_idf > 0) %>%
  arrange(desc(tf_idf)) %>%
  group_by(super.tipo) %>%
  top_n(10, tf_idf) %>% 
  filter(row_number() <= 10) %>% 
  # ordena por tipo e score (desc)
  arrange(super.tipo, desc(tf_idf)) %>%
  ungroup() %>%
  # atribui um rank para cada palavra dentro do tipo (facilitar o plot) 
  mutate(Rank = rep(10:1, 2)) %>%
  ggplot(aes(x=as.factor(Rank), y=tf_idf)) +  
    geom_bar(stat="identity", fill="cadetblue", alpha=0.5) + 
    coord_flip() + facet_wrap(~super.tipo,ncol=4) + 
    geom_text(aes(label=word, x=Rank), y=0,hjust=0, size=4) +
    labs(title="10 palavras com mais TF-IDF por tipo de cerveja", 
         x="", y="tf-idf") +
    theme_bw() + 
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())

```

Agora podemos observar que elementos como `caramelo x chocolate`, `marrom x preta`, `coco x baunilha` e `herbáceo x seco` são elementos que diferencia a _American Brown Ale_ de uma _English Porter_.

Essas informações são interessantes em um sistema de sugestões, você pode procurar primeiro pelo cluster similar (pertencente na verdade) ao produto que o usuário já gosta e então dentro do cluster navegar pelas diferenças sugerindo direções como +frutada, +chocolate, +leve, etc.

## Conclusão

Podemos observar como técnicas de processamento de texto nos dão _insights_ relevantes sobre produtos, podendo nos dar graus de similaridade/dissimilaridade, oferecendo oportunidades econômicas interessantes.

Uma evolução interessante deste trabalho seria de fato criar uma aplicação trivial que pudesse oferecer sugestões de cervejas, dada uma cerveja ou a descrição do sabor desejado (ou não desejado).
